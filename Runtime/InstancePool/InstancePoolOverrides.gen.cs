//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using UnityEngine;
using System.Collections;

namespace Vertx.Utilities
{
	public static partial class InstancePool
	{
		/// <summary>
		/// Returns the amount of pooled instances associated with a prefab key.
		/// </summary>
		/// <param name="key">The prefab key.</param>
		/// <returns>The amount of pooled instances associated with the key.</returns>
		public static int GetCurrentlyPooledCount<TInstanceType>(TInstanceType key)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.GetCurrentlyPooledCount(key);

		public static bool HasPool<TInstanceType>(TInstanceType prefab)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.HasPool(prefab);
		
		public static bool HasPool<TInstanceType, TPoolType>(TInstanceType prefab)
			where TInstanceType : Component
			where TPoolType : IComponentPool<TInstanceType>
			=> InstancePool<TInstanceType>.HasPool<TPoolType>(prefab);

		/// <summary>
		/// Overrides the default <see cref="ExpandablePool{TInstanceType}"/> used by InstancePool with another instance.<br/>
		/// If there is a pre-existing pool, instances are moved to the new pool.
		/// </summary>
		/// <param name="pool">The new pool to switch to.</param>
		public static void Override<TInstanceType>(IComponentPool<TInstanceType> pool)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.Override(pool);

		/// <summary>
		/// Ensures the pool has <see cref="count"/> number of instances of <see cref="prefab"/> pooled.
		/// </summary>
		/// <param name="prefab">The prefab key to instance.</param>
		/// <param name="count">The amount to ensure is pooled.</param>
		/// <param name="parent">Optional parent.</param>
		public static void Warmup<TInstanceType>(TInstanceType prefab, int count, Transform parent = null)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.Warmup(prefab, count, parent);

		/// <summary>
		/// Ensures the pool has <see cref="count"/> number of instances of <see cref="prefab"/> pooled.
		/// </summary>
		/// <param name="prefab">The prefab key to instance.</param>
		/// <param name="count">The amount to ensure is pooled.</param>
		/// <param name="parent">Optional parent.</param>
		/// <param name="instancesPerFrame">The amount of instances created per frame.</param>
		public static IEnumerator WarmupCoroutine<TInstanceType>(TInstanceType prefab, int count, Transform parent = null, int instancesPerFrame = 1)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.WarmupCoroutine(prefab, count, parent, instancesPerFrame);

		/// <summary>
		/// Retrieves an instance from the pool, positioned at the origin.
		/// </summary>
		/// <param name="prefab">The prefab key to retrieve instances of.</param>
		/// <param name="parent">The parent to parent instances under.</param>
		/// <returns>An instance retrieved from the pool.</returns>
		public static TInstanceType Get<TInstanceType>(TInstanceType prefab, Transform parent = null)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.Get(prefab, parent);

		/// <summary>
		/// Retrieves a positioned instance from the pool.
		/// </summary>
		/// <param name="prefab">The prefab key to retrieve instances of.</param>
		/// <param name="parent">The parent to parent instances under.</param>
		/// <param name="position">Position of the instance</param>
		/// <param name="rotation">Rotation of the instance</param>
		/// <param name="space">Which space the position and rotation is applied in</param>
		/// <returns>An instance retrieved from the pool.</returns>
		public static TInstanceType Get<TInstanceType>(TInstanceType prefab, Transform parent, Vector3 position, Quaternion rotation, Space space = Space.World)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.Get(prefab, parent, position, rotation, space);

		/// <summary>
		/// Retrieves a positioned instance from the pool.
		/// </summary>
		/// <param name="prefab">The prefab key to retrieve instances of.</param>
		/// <param name="parent">The parent to parent instances under.</param>
		/// <param name="position">Position of the instance.</param>
		/// <param name="rotation">Rotation of the instance.</param>
		/// <param name="localScale">Local Scale of the instance.</param>
		/// <param name="space">Which space the position and rotation is applied in.</param>
		/// <returns>An instance retrieved from the pool.</returns>
		public static TInstanceType Get<TInstanceType>(TInstanceType prefab, Transform parent, Vector3 position, Quaternion rotation, Vector3 localScale, Space space = Space.World)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.Get(prefab, parent, position, rotation, localScale, space);

		/// <summary>
		/// Returns a Component instance to the pool.
		/// </summary>
		/// <param name="prefab">The prefab key used when the instance was retrieved via <see cref="Get(TInstanceType,Transform)"/>.</param>
		/// <param name="instance">The instance to return to the pool.</param>
		public static void Pool<TInstanceType>(TInstanceType prefab, TInstanceType instance)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.Pool(prefab, instance);

		/// <summary>
		/// Queries whether the pool contains a specific instance of a prefab.
		/// </summary>
		/// <param name="prefab">The prefab key referring to the pool.</param>
		/// <param name="instance">The instance we are querying.</param>
		/// <returns>True if the pool contains the queried instance.</returns>
		public static bool IsPooled<TInstanceType>(TInstanceType prefab, TInstanceType instance)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.IsPooled(prefab, instance);

		/// <summary>
		/// Removes references to all static pools.
		/// This does not remove the instance pool scene, and any object that is currently pooled can and will leak into that scene unless handled manually.
		/// </summary>
		public static void RemovePools<TInstanceType>()
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.RemovePools();

		/// <summary>
		/// When working with temporary pools this will remove all of them associated with a component type from the system.<br/>
		/// This will not remove the instances that are currently pooled. Un-pool all instances before calling this function.
		/// </summary>
		/// /// <param name="handlePooledInstance">A callback for dealing with instances that are in the pool.</param>
		public static void RemovePools<TInstanceType>(Action<TInstanceType> handlePooledInstance)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.RemovePools(handlePooledInstance);

		/// <summary>
		/// When working with temporary pools this will remove them from the system.<br/>
		/// This will not remove the instances that are currently pooled. Un-pool all instances before calling this function.
		/// </summary>
		/// <param name="prefab">The prefab key referring to the pool.</param>
		/// <returns>The pool that was removed. Null otherwise.</returns>
		public static IComponentPool<TInstanceType> RemovePool<TInstanceType>(TInstanceType prefab)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.RemovePool(prefab);

		/// <summary>
		/// When working with temporary pools this will remove them from the system..<br/>
		/// Handle the currently pooled instances with the <see cref="handlePooledInstance"/> parameter.
		/// </summary>
		/// <param name="prefab">The prefab key referring to the pool.</param>
		/// <param name="handlePooledInstance">A callback for dealing with instances that are in the pool.</param>
		/// /// <returns>The pool that was removed. Null otherwise.</returns>
		public static IComponentPool<TInstanceType> RemovePool<TInstanceType>(TInstanceType prefab, Action<TInstanceType> handlePooledInstance)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.RemovePool(prefab, handlePooledInstance);

		/// <summary>
		/// Sets the capacity used by <see cref="TrimExcess(System.Nullable{int})"/> for all instances shared between the type <see cref="TInstanceType"/>
		/// </summary>
		/// <param name="capacity">The maximum amount of instances kept when <see cref="TrimExcess(System.Nullable{int})"/> is called.</param>
		public static void SetCapacities<TInstanceType>(int capacity)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.SetCapacities(capacity);

		/// <summary>
		/// Sets the capacity used by <see cref="TrimExcess(System.Nullable{int})"/>
		/// </summary>
		/// <param name="prefab">The prefab used as a key within the pool.</param>
		/// <param name="capacity">The maximum amount of instances kept when <see cref="TrimExcess(System.Nullable{int})"/> is called.</param>
		public static void SetCapacity<TInstanceType>(TInstanceType prefab, int capacity)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.SetCapacity(prefab, capacity);

		/// <summary>
		/// Destroys extra instances beyond the capacities set.<br/>
		/// The default capacity is 20 if <see cref="SetCapacity"/> or <see cref="SetCapacities"/> was not set.
		/// <param name="capacityOverride">Optional capacity override.</param>
		/// </summary>
		public static void TrimExcess<TInstanceType>(int? capacityOverride = null)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.TrimExcess(capacityOverride);

		/// <summary>
		/// Destroys extra instances beyond the capacities set.<br/>
		/// The default capacity is 20 if <see cref="SetCapacity"/> or <see cref="SetCapacities"/> was not set.
		/// </summary>
		/// <param name="prefab">The prefab used as a key within the pool.</param>
		/// <param name="capacity">Optional capacity override.</param>
		public static void TrimExcess<TInstanceType>(TInstanceType prefab, int? capacity = null)
			where TInstanceType : Component
			=> InstancePool<TInstanceType>.TrimExcess(prefab, capacity);
	}
}